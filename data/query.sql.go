// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package data

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteMessage = `-- name: DeleteMessage :one
DELETE FROM public.messages
WHERE id = $1
RETURNING
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
`

type DeleteMessageRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) (DeleteMessageRow, error) {
	row := q.db.QueryRow(ctx, deleteMessage, id)
	var i DeleteMessageRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO public.messages (email_creator, email_receivers, message_content, inactive_period_days,
  reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING
  id, created_at, email_creator, email_receivers, message_content, inactive_period_days,
    reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at
`

type InsertMessageParams struct {
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

type InsertMessageRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (InsertMessageRow, error) {
	row := q.db.QueryRow(ctx, insertMessage,
		arg.EmailCreator,
		arg.EmailReceivers,
		arg.MessageContent,
		arg.InactivePeriodDays,
		arg.ReminderIntervalDays,
		arg.IsActive,
		arg.ExtensionSecret,
		arg.InactiveAt,
		arg.NextReminderAt,
	)
	var i InsertMessageRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const selectInactiveMessages = `-- name: SelectInactiveMessages :many
SELECT
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
FROM
  public.messages
WHERE
  inactive_at < $1
LIMIT 100
`

type SelectInactiveMessagesRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) SelectInactiveMessages(ctx context.Context, inactiveAt time.Time) ([]SelectInactiveMessagesRow, error) {
	rows, err := q.db.Query(ctx, selectInactiveMessages, inactiveAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectInactiveMessagesRow
	for rows.Next() {
		var i SelectInactiveMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.EmailCreator,
			&i.EmailReceivers,
			&i.MessageContent,
			&i.InactivePeriodDays,
			&i.ReminderIntervalDays,
			&i.IsActive,
			&i.ExtensionSecret,
			&i.InactiveAt,
			&i.NextReminderAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMessageByID = `-- name: SelectMessageByID :one
SELECT
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
FROM
  public.messages
WHERE
  id = $1
`

type SelectMessageByIDRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) SelectMessageByID(ctx context.Context, id uuid.UUID) (SelectMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, selectMessageByID, id)
	var i SelectMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const selectMessagesByEmailCreator = `-- name: SelectMessagesByEmailCreator :many
SELECT
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
FROM
  public.messages
WHERE
  email_creator = $1
`

type SelectMessagesByEmailCreatorRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) SelectMessagesByEmailCreator(ctx context.Context, emailCreator string) ([]SelectMessagesByEmailCreatorRow, error) {
	rows, err := q.db.Query(ctx, selectMessagesByEmailCreator, emailCreator)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectMessagesByEmailCreatorRow
	for rows.Next() {
		var i SelectMessagesByEmailCreatorRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.EmailCreator,
			&i.EmailReceivers,
			&i.MessageContent,
			&i.InactivePeriodDays,
			&i.ReminderIntervalDays,
			&i.IsActive,
			&i.ExtensionSecret,
			&i.InactiveAt,
			&i.NextReminderAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMessagesNeedReminding = `-- name: SelectMessagesNeedReminding :many
SELECT
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
FROM
  public.messages
WHERE
  next_reminder_at < $1
LIMIT 100
`

type SelectMessagesNeedRemindingRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) SelectMessagesNeedReminding(ctx context.Context, nextReminderAt time.Time) ([]SelectMessagesNeedRemindingRow, error) {
	rows, err := q.db.Query(ctx, selectMessagesNeedReminding, nextReminderAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectMessagesNeedRemindingRow
	for rows.Next() {
		var i SelectMessagesNeedRemindingRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.EmailCreator,
			&i.EmailReceivers,
			&i.MessageContent,
			&i.InactivePeriodDays,
			&i.ReminderIntervalDays,
			&i.IsActive,
			&i.ExtensionSecret,
			&i.InactiveAt,
			&i.NextReminderAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE
  public.messages
SET
  email_creator = $1,
  email_receivers = $2,
  message_content = $3,
  inactive_period_days = $4,
  reminder_interval_days = $5,
  is_active = $6,
  extension_secret = $7,
  inactive_at = CURRENT_DATE + (inactive_period_days || ' days')::interval,
  next_reminder_at = CURRENT_DATE + (reminder_interval_days || ' days')::interval
WHERE
  id = $8
RETURNING
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
`

type UpdateMessageParams struct {
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	ID                   uuid.UUID
}

type UpdateMessageRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (UpdateMessageRow, error) {
	row := q.db.QueryRow(ctx, updateMessage,
		arg.EmailCreator,
		arg.EmailReceivers,
		arg.MessageContent,
		arg.InactivePeriodDays,
		arg.ReminderIntervalDays,
		arg.IsActive,
		arg.ExtensionSecret,
		arg.ID,
	)
	var i UpdateMessageRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const updateMessageAfterSendingReminder = `-- name: UpdateMessageAfterSendingReminder :one
UPDATE
  public.messages
SET
  next_reminder_at = CURRENT_DATE + (reminder_interval_days || ' days')::interval
WHERE
  id = $1
RETURNING
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
`

type UpdateMessageAfterSendingReminderRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) UpdateMessageAfterSendingReminder(ctx context.Context, id uuid.UUID) (UpdateMessageAfterSendingReminderRow, error) {
	row := q.db.QueryRow(ctx, updateMessageAfterSendingReminder, id)
	var i UpdateMessageAfterSendingReminderRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const updateMessageAfterSendingTestament = `-- name: UpdateMessageAfterSendingTestament :one
UPDATE
  public.messages
SET
  inactive_at = CURRENT_DATE + (15 || ' days')::interval,
  next_reminder_at = CURRENT_DATE + (30 || ' days')::interval
WHERE
  id = $1
RETURNING
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
`

type UpdateMessageAfterSendingTestamentRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) UpdateMessageAfterSendingTestament(ctx context.Context, id uuid.UUID) (UpdateMessageAfterSendingTestamentRow, error) {
	row := q.db.QueryRow(ctx, updateMessageAfterSendingTestament, id)
	var i UpdateMessageAfterSendingTestamentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}

const updateMessageExtendsInactiveAt = `-- name: UpdateMessageExtendsInactiveAt :one
UPDATE
  public.messages
SET
  extension_secret = $1,
  inactive_at = CURRENT_DATE + (inactive_period_days || ' days')::interval,
  next_reminder_at = CURRENT_DATE + (reminder_interval_days || ' days')::interval
WHERE
  id = $2
  AND extension_secret = $3
RETURNING
  id,
  created_at,
  email_creator,
  email_receivers,
  message_content,
  inactive_period_days,
  reminder_interval_days,
  is_active,
  extension_secret,
  inactive_at,
  next_reminder_at
`

type UpdateMessageExtendsInactiveAtParams struct {
	ExtensionSecret   string
	ID                uuid.UUID
	ExtensionSecret_2 string
}

type UpdateMessageExtendsInactiveAtRow struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	EmailCreator         string
	EmailReceivers       []string
	MessageContent       string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	InactiveAt           time.Time
	NextReminderAt       time.Time
}

func (q *Queries) UpdateMessageExtendsInactiveAt(ctx context.Context, arg UpdateMessageExtendsInactiveAtParams) (UpdateMessageExtendsInactiveAtRow, error) {
	row := q.db.QueryRow(ctx, updateMessageExtendsInactiveAt, arg.ExtensionSecret, arg.ID, arg.ExtensionSecret_2)
	var i UpdateMessageExtendsInactiveAtRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EmailCreator,
		&i.EmailReceivers,
		&i.MessageContent,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
	)
	return i, err
}
