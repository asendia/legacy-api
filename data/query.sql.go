// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteMessage = `-- name: DeleteMessage :one
DELETE FROM messages
WHERE id = $1
  AND email_creator = $2
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

type DeleteMessageParams struct {
	ID           uuid.UUID
	EmailCreator string
}

func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, deleteMessage, arg.ID, arg.EmailCreator)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const insertMessage = `-- name: InsertMessage :one
WITH insert_email AS (
INSERT INTO emails (email)
    VALUES ($1)
  ON CONFLICT
    DO NOTHING
  RETURNING
    email)
  INSERT INTO messages (email_creator, content_encrypted, inactive_period_days,
    reminder_interval_days, extension_secret, inactive_at, next_reminder_at)
  SELECT
    $1,
    $2,
    $3,
    $4,
    $5,
    CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, $3),
    CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, $4)
  WHERE (
    SELECT
      count(*)
    FROM
      messages
    WHERE
      messages.email_creator = $1) < 3
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

type InsertMessageParams struct {
	EmailCreator         string
	ContentEncrypted     string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	ExtensionSecret      string
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, insertMessage,
		arg.EmailCreator,
		arg.ContentEncrypted,
		arg.InactivePeriodDays,
		arg.ReminderIntervalDays,
		arg.ExtensionSecret,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const selectInactiveMessages = `-- name: SelectInactiveMessages :many
SELECT
  emails.email AS usr_email,
  emails.created_at AS usr_created_at,
  emails.is_active AS usr_is_active,
  messages.id AS msg_id,
  messages.email_creator AS msg_email_creator,
  messages.created_at AS msg_created_at,
  messages.content_encrypted AS msg_content_encrypted,
  messages.inactive_period_days AS msg_inactive_period_days,
  messages.reminder_interval_days AS msg_reminder_interval_days,
  messages.is_active AS msg_is_active,
  messages.extension_secret AS msg_extension_secret,
  messages.inactive_at AS msg_inactive_at,
  messages.next_reminder_at AS msg_next_reminder_at,
  messages.sent_counter AS msg_sent_counter,
  receivers.message_id AS rcv_message_id,
  receivers.email_receiver AS rcv_email_receiver,
  receivers.is_unsubscribed AS rcv_is_unsubscribed,
  receivers.unsubscribe_secret AS rcv_unsubscribe_secret
FROM
  emails
  INNER JOIN messages ON emails.email = messages.email_creator
  INNER JOIN messages_email_receivers AS receivers ON messages.id = receivers.message_id
WHERE
  messages.inactive_at < CURRENT_DATE
  AND messages.content_encrypted <> ''
  AND messages.is_active
  AND messages.sent_counter < 3
  AND receivers.is_unsubscribed = FALSE
ORDER BY
  messages.created_at ASC,
  messages.id ASC
LIMIT 100
`

type SelectInactiveMessagesRow struct {
	UsrEmail                string
	UsrCreatedAt            time.Time
	UsrIsActive             bool
	MsgID                   uuid.UUID
	MsgEmailCreator         string
	MsgCreatedAt            time.Time
	MsgContentEncrypted     string
	MsgInactivePeriodDays   int32
	MsgReminderIntervalDays int32
	MsgIsActive             bool
	MsgExtensionSecret      string
	MsgInactiveAt           time.Time
	MsgNextReminderAt       time.Time
	MsgSentCounter          int32
	RcvMessageID            uuid.UUID
	RcvEmailReceiver        string
	RcvIsUnsubscribed       bool
	RcvUnsubscribeSecret    string
}

func (q *Queries) SelectInactiveMessages(ctx context.Context) ([]SelectInactiveMessagesRow, error) {
	rows, err := q.db.Query(ctx, selectInactiveMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectInactiveMessagesRow
	for rows.Next() {
		var i SelectInactiveMessagesRow
		if err := rows.Scan(
			&i.UsrEmail,
			&i.UsrCreatedAt,
			&i.UsrIsActive,
			&i.MsgID,
			&i.MsgEmailCreator,
			&i.MsgCreatedAt,
			&i.MsgContentEncrypted,
			&i.MsgInactivePeriodDays,
			&i.MsgReminderIntervalDays,
			&i.MsgIsActive,
			&i.MsgExtensionSecret,
			&i.MsgInactiveAt,
			&i.MsgNextReminderAt,
			&i.MsgSentCounter,
			&i.RcvMessageID,
			&i.RcvEmailReceiver,
			&i.RcvIsUnsubscribed,
			&i.RcvUnsubscribeSecret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMessage = `-- name: SelectMessage :many
SELECT
  emails.email AS usr_email,
  emails.created_at AS usr_created_at,
  emails.is_active AS usr_is_active,
  messages.id AS msg_id,
  messages.email_creator AS msg_email_creator,
  messages.created_at AS msg_created_at,
  messages.content_encrypted AS msg_content_encrypted,
  messages.inactive_period_days AS msg_inactive_period_days,
  messages.reminder_interval_days AS msg_reminder_interval_days,
  messages.is_active AS msg_is_active,
  messages.extension_secret AS msg_extension_secret,
  messages.inactive_at AS msg_inactive_at,
  messages.next_reminder_at AS msg_next_reminder_at,
  messages.sent_counter AS msg_sent_counter,
  receivers.message_id AS rcv_message_id,
  receivers.email_receiver AS rcv_email_receiver,
  receivers.is_unsubscribed AS rcv_is_unsubscribed,
  receivers.unsubscribe_secret AS rcv_unsubscribe_secret
FROM
  emails
  INNER JOIN messages ON messages.email_creator = emails.email
  LEFT JOIN messages_email_receivers AS receivers ON messages.id = receivers.message_id
WHERE
  messages.id = $1
  AND emails.is_active
ORDER BY
  messages.created_at ASC
LIMIT 10
`

type SelectMessageRow struct {
	UsrEmail                string
	UsrCreatedAt            time.Time
	UsrIsActive             bool
	MsgID                   uuid.UUID
	MsgEmailCreator         string
	MsgCreatedAt            time.Time
	MsgContentEncrypted     string
	MsgInactivePeriodDays   int32
	MsgReminderIntervalDays int32
	MsgIsActive             bool
	MsgExtensionSecret      string
	MsgInactiveAt           time.Time
	MsgNextReminderAt       time.Time
	MsgSentCounter          int32
	RcvMessageID            uuid.NullUUID
	RcvEmailReceiver        sql.NullString
	RcvIsUnsubscribed       sql.NullBool
	RcvUnsubscribeSecret    sql.NullString
}

func (q *Queries) SelectMessage(ctx context.Context, id uuid.UUID) ([]SelectMessageRow, error) {
	rows, err := q.db.Query(ctx, selectMessage, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectMessageRow
	for rows.Next() {
		var i SelectMessageRow
		if err := rows.Scan(
			&i.UsrEmail,
			&i.UsrCreatedAt,
			&i.UsrIsActive,
			&i.MsgID,
			&i.MsgEmailCreator,
			&i.MsgCreatedAt,
			&i.MsgContentEncrypted,
			&i.MsgInactivePeriodDays,
			&i.MsgReminderIntervalDays,
			&i.MsgIsActive,
			&i.MsgExtensionSecret,
			&i.MsgInactiveAt,
			&i.MsgNextReminderAt,
			&i.MsgSentCounter,
			&i.RcvMessageID,
			&i.RcvEmailReceiver,
			&i.RcvIsUnsubscribed,
			&i.RcvUnsubscribeSecret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMessagesByEmailCreator = `-- name: SelectMessagesByEmailCreator :many
SELECT
  emails.email AS usr_email,
  emails.created_at AS usr_created_at,
  emails.is_active AS usr_is_active,
  messages.id AS msg_id,
  messages.email_creator AS msg_email_creator,
  messages.created_at AS msg_created_at,
  messages.content_encrypted AS msg_content_encrypted,
  messages.inactive_period_days AS msg_inactive_period_days,
  messages.reminder_interval_days AS msg_reminder_interval_days,
  messages.is_active AS msg_is_active,
  messages.extension_secret AS msg_extension_secret,
  messages.inactive_at AS msg_inactive_at,
  messages.next_reminder_at AS msg_next_reminder_at,
  messages.sent_counter AS msg_sent_counter,
  receivers.message_id AS rcv_message_id,
  receivers.email_receiver AS rcv_email_receiver,
  receivers.is_unsubscribed AS rcv_is_unsubscribed,
  receivers.unsubscribe_secret AS rcv_unsubscribe_secret
FROM
  emails
  INNER JOIN messages ON messages.email_creator = emails.email
  LEFT JOIN messages_email_receivers AS receivers ON messages.id = receivers.message_id
WHERE
  messages.email_creator = $1
  AND emails.is_active
ORDER BY
  messages.created_at ASC
LIMIT 30
`

type SelectMessagesByEmailCreatorRow struct {
	UsrEmail                string
	UsrCreatedAt            time.Time
	UsrIsActive             bool
	MsgID                   uuid.UUID
	MsgEmailCreator         string
	MsgCreatedAt            time.Time
	MsgContentEncrypted     string
	MsgInactivePeriodDays   int32
	MsgReminderIntervalDays int32
	MsgIsActive             bool
	MsgExtensionSecret      string
	MsgInactiveAt           time.Time
	MsgNextReminderAt       time.Time
	MsgSentCounter          int32
	RcvMessageID            uuid.NullUUID
	RcvEmailReceiver        sql.NullString
	RcvIsUnsubscribed       sql.NullBool
	RcvUnsubscribeSecret    sql.NullString
}

func (q *Queries) SelectMessagesByEmailCreator(ctx context.Context, emailCreator string) ([]SelectMessagesByEmailCreatorRow, error) {
	rows, err := q.db.Query(ctx, selectMessagesByEmailCreator, emailCreator)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectMessagesByEmailCreatorRow
	for rows.Next() {
		var i SelectMessagesByEmailCreatorRow
		if err := rows.Scan(
			&i.UsrEmail,
			&i.UsrCreatedAt,
			&i.UsrIsActive,
			&i.MsgID,
			&i.MsgEmailCreator,
			&i.MsgCreatedAt,
			&i.MsgContentEncrypted,
			&i.MsgInactivePeriodDays,
			&i.MsgReminderIntervalDays,
			&i.MsgIsActive,
			&i.MsgExtensionSecret,
			&i.MsgInactiveAt,
			&i.MsgNextReminderAt,
			&i.MsgSentCounter,
			&i.RcvMessageID,
			&i.RcvEmailReceiver,
			&i.RcvIsUnsubscribed,
			&i.RcvUnsubscribeSecret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMessagesNeedReminding = `-- name: SelectMessagesNeedReminding :many
SELECT
  emails.email AS usr_email,
  emails.created_at AS usr_created_at,
  emails.is_active AS usr_is_active,
  messages.id AS msg_id,
  messages.email_creator AS msg_email_creator,
  messages.created_at AS msg_created_at,
  messages.content_encrypted AS msg_content_encrypted,
  messages.inactive_period_days AS msg_inactive_period_days,
  messages.reminder_interval_days AS msg_reminder_interval_days,
  messages.is_active AS msg_is_active,
  messages.extension_secret AS msg_extension_secret,
  messages.inactive_at AS msg_inactive_at,
  messages.next_reminder_at AS msg_next_reminder_at,
  messages.sent_counter AS msg_sent_counter,
  message_id AS rcv_message_id,
  receivers.email_receiver AS rcv_email_receiver,
  receivers.is_unsubscribed AS rcv_is_unsubscribed,
  receivers.unsubscribe_secret AS rcv_unsubscribe_secret
FROM
  emails
  INNER JOIN messages ON emails.email = messages.email_creator
  INNER JOIN messages_email_receivers AS receivers ON messages.id = receivers.message_id
WHERE
  messages.is_active
  AND messages.content_encrypted <> ''
  AND messages.next_reminder_at <= CURRENT_DATE
  AND receivers.is_unsubscribed = FALSE
ORDER BY
  messages.created_at ASC,
  messages.id ASC
LIMIT 100
`

type SelectMessagesNeedRemindingRow struct {
	UsrEmail                string
	UsrCreatedAt            time.Time
	UsrIsActive             bool
	MsgID                   uuid.UUID
	MsgEmailCreator         string
	MsgCreatedAt            time.Time
	MsgContentEncrypted     string
	MsgInactivePeriodDays   int32
	MsgReminderIntervalDays int32
	MsgIsActive             bool
	MsgExtensionSecret      string
	MsgInactiveAt           time.Time
	MsgNextReminderAt       time.Time
	MsgSentCounter          int32
	RcvMessageID            uuid.UUID
	RcvEmailReceiver        string
	RcvIsUnsubscribed       bool
	RcvUnsubscribeSecret    string
}

func (q *Queries) SelectMessagesNeedReminding(ctx context.Context) ([]SelectMessagesNeedRemindingRow, error) {
	rows, err := q.db.Query(ctx, selectMessagesNeedReminding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectMessagesNeedRemindingRow
	for rows.Next() {
		var i SelectMessagesNeedRemindingRow
		if err := rows.Scan(
			&i.UsrEmail,
			&i.UsrCreatedAt,
			&i.UsrIsActive,
			&i.MsgID,
			&i.MsgEmailCreator,
			&i.MsgCreatedAt,
			&i.MsgContentEncrypted,
			&i.MsgInactivePeriodDays,
			&i.MsgReminderIntervalDays,
			&i.MsgIsActive,
			&i.MsgExtensionSecret,
			&i.MsgInactiveAt,
			&i.MsgNextReminderAt,
			&i.MsgSentCounter,
			&i.RcvMessageID,
			&i.RcvEmailReceiver,
			&i.RcvIsUnsubscribed,
			&i.RcvUnsubscribeSecret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmail = `-- name: UpdateEmail :exec
UPDATE
  emails
SET
  is_active = $1
WHERE
  email = $2
`

type UpdateEmailParams struct {
	IsActive bool
	Email    string
}

func (q *Queries) UpdateEmail(ctx context.Context, arg UpdateEmailParams) error {
	_, err := q.db.Exec(ctx, updateEmail, arg.IsActive, arg.Email)
	return err
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE
  messages
SET
  content_encrypted = $1,
  inactive_period_days = $2,
  reminder_interval_days = $3,
  is_active = $4,
  extension_secret = $5,
  inactive_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, $2),
  next_reminder_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, $3),
  sent_counter = 0
WHERE
  id = $6
  AND email_creator = $7
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

type UpdateMessageParams struct {
	ContentEncrypted     string
	InactivePeriodDays   int32
	ReminderIntervalDays int32
	IsActive             bool
	ExtensionSecret      string
	ID                   uuid.UUID
	EmailCreator         string
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage,
		arg.ContentEncrypted,
		arg.InactivePeriodDays,
		arg.ReminderIntervalDays,
		arg.IsActive,
		arg.ExtensionSecret,
		arg.ID,
		arg.EmailCreator,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const updateMessageAfterSendingReminder = `-- name: UpdateMessageAfterSendingReminder :one
UPDATE
  messages
SET
  next_reminder_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, reminder_interval_days)
WHERE
  id = $1
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

func (q *Queries) UpdateMessageAfterSendingReminder(ctx context.Context, id uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessageAfterSendingReminder, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const updateMessageAfterSendingTestament = `-- name: UpdateMessageAfterSendingTestament :one
UPDATE
  messages
SET
  is_active = CASE WHEN sent_counter < 2 THEN
    is_active
  ELSE
    FALSE
  END,
  sent_counter = sent_counter + 1,
  inactive_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, 15),
  next_reminder_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, 30)
WHERE
  id = $1
  AND sent_counter < 3
  AND is_active
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

func (q *Queries) UpdateMessageAfterSendingTestament(ctx context.Context, id uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessageAfterSendingTestament, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const updateMessageExtendsInactiveAt = `-- name: UpdateMessageExtendsInactiveAt :one
UPDATE
  messages
SET
  extension_secret = $1,
  inactive_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, inactive_period_days),
  next_reminder_at = CURRENT_DATE + MAKE_INTERVAL(0, 0, 0, reminder_interval_days)
WHERE
  id = $2
  AND extension_secret = $3
  AND inactive_at >= CURRENT_DATE
  AND is_active
RETURNING
  id, email_creator, created_at, content_encrypted, inactive_period_days, reminder_interval_days, is_active, extension_secret, inactive_at, next_reminder_at, sent_counter
`

type UpdateMessageExtendsInactiveAtParams struct {
	ExtensionSecret   string
	ID                uuid.UUID
	ExtensionSecret_2 string
}

func (q *Queries) UpdateMessageExtendsInactiveAt(ctx context.Context, arg UpdateMessageExtendsInactiveAtParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessageExtendsInactiveAt, arg.ExtensionSecret, arg.ID, arg.ExtensionSecret_2)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.EmailCreator,
		&i.CreatedAt,
		&i.ContentEncrypted,
		&i.InactivePeriodDays,
		&i.ReminderIntervalDays,
		&i.IsActive,
		&i.ExtensionSecret,
		&i.InactiveAt,
		&i.NextReminderAt,
		&i.SentCounter,
	)
	return i, err
}

const updateReceiverUnsubscribe = `-- name: UpdateReceiverUnsubscribe :one
UPDATE
  messages_email_receivers
SET
  is_unsubscribed = TRUE
WHERE
  message_id = $1
  AND unsubscribe_secret = $2
RETURNING
  message_id, email_receiver, is_unsubscribed, unsubscribe_secret
`

type UpdateReceiverUnsubscribeParams struct {
	MessageID         uuid.UUID
	UnsubscribeSecret string
}

func (q *Queries) UpdateReceiverUnsubscribe(ctx context.Context, arg UpdateReceiverUnsubscribeParams) (MessagesEmailReceiver, error) {
	row := q.db.QueryRow(ctx, updateReceiverUnsubscribe, arg.MessageID, arg.UnsubscribeSecret)
	var i MessagesEmailReceiver
	err := row.Scan(
		&i.MessageID,
		&i.EmailReceiver,
		&i.IsUnsubscribed,
		&i.UnsubscribeSecret,
	)
	return i, err
}

const upsertReceivers = `-- name: UpsertReceivers :many
WITH insert_email AS (
INSERT INTO emails
  SELECT
    unnest($2::text[]) AS email
  ON CONFLICT
    DO NOTHING
),
delete_receivers AS (
  DELETE FROM messages_email_receivers
  WHERE messages_email_receivers.message_id = $1
    AND messages_email_receivers.is_unsubscribed = FALSE
    AND messages_email_receivers.email_receiver NOT IN (
      SELECT
        unnest($2::text[])))
INSERT INTO messages_email_receivers (message_id, email_receiver, unsubscribe_secret)
SELECT
  $1 AS message_id,
  unnest($2::text[]) AS email_receiver,
  unnest($3::text[]) AS unsubscribe_secret
ON CONFLICT
  DO NOTHING
RETURNING
  message_id, email_receiver, is_unsubscribed, unsubscribe_secret
`

type UpsertReceiversParams struct {
	MessageID          uuid.UUID
	EmailReceivers     []string
	UnsubscribeSecrets []string
}

func (q *Queries) UpsertReceivers(ctx context.Context, arg UpsertReceiversParams) ([]MessagesEmailReceiver, error) {
	rows, err := q.db.Query(ctx, upsertReceivers, arg.MessageID, arg.EmailReceivers, arg.UnsubscribeSecrets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessagesEmailReceiver
	for rows.Next() {
		var i MessagesEmailReceiver
		if err := rows.Scan(
			&i.MessageID,
			&i.EmailReceiver,
			&i.IsUnsubscribed,
			&i.UnsubscribeSecret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
